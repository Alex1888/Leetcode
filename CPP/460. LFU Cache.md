# [460. LFU Cache](https://leetcode.com/problems/lfu-cache/description/)
* http://www.cnblogs.com/grandyang/p/6258459.html

```c++

class LFUCache {
public:
    LFUCache(int capacity) {
        cap = capacity;
        minFreq = 0;
    }
    
    int get(int key) {
        if(m.count(key) == 0) return -1;
        int f = m[key].second; // 当前没更新的频率
        freq[f].erase(iter[key]); // 在freq中删除key现在的频率
        f++;
        m[key].second = f;  // 更新频率
        freq[f].push_back(key); // 把key加入到新频率的list
        iter[key] = --freq[f].end(); // 更新iter中新频率对应的位置
        if(freq[minFreq].size() == 0) minFreq++;
        return m[key].first;   
    }
    
    void put(int key, int value) {
        if(cap <= 0) return;
        if(get(key) != -1){
            m[key].first = value; // 注意: put操作不算频率更新
            return;
        }
        
        if(m.size() >= cap){
            int min_key = freq[minFreq].front(); // 最前面的肯定是least recently的
            m.erase(min_key);
            iter.erase(min_key);
            freq[minFreq].pop_front();
        }
        
        //更新新元素的信息
        m[key] = {value, 1};
        freq[1].push_back(key);
        iter[key] = --freq[1].end();
        minFreq = 1;
    }
    
private:
    int cap, minFreq;
    unordered_map<int, pair<int, int>> m; // key就是元素的key, pair.first是元素的value, second是元素的频率
    unordered_map<int, list<int>> freq; // key是频率,list是这个频率下对应的元素的key的list,最前面的是least recently的
    unordered_map<int, list<int>::iterator> iter; // key是元素的key, value是这个key在freq中的对应频率的list中的位置;
    // 对于iter,就可以先通过f = m[key].second 找到对应的频率,然后再用iter[f].second 就能定位到freq[f] 这个list中的位置
};

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache obj = new LFUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```
