# [84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)
* O(n2)的解法，最大面积肯定出现在峰值，所以找到每一个峰值，然后往前遍历。每次都更新area
* http://www.cnblogs.com/grandyang/p/4322653.html

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int res = 0;
        
        for(int i=0; i<heights.size(); i++){
            if(i < heights.size() - 1 && heights[i] <= heights[i+1]){
                continue;
            }
            
            int minh = heights[i];
            for(int j=i; j>=0; j--){
                minh = min(heights[j], minh);
                int area = minh * (i - j + 1);
                res = max(area, res);
            }
        }
        
        return res;
    }
};

```

* 单调栈的解法,维护一个递增的栈,如果遇到第一个比top小的数,则开始处理
* 道理同上面的相同,因为最大值肯定出现在峰值,所有当前值是不参与处理的,而是从top的值开始
* 注意的是栈里保存的元素是下标

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        stack<int> sk;
        heights.push_back(0);
        int res = 0;
        
        for(int i=0; i<heights.size(); i++){
            if(sk.empty() || heights[sk.top()] <= heights[i]){
                sk.push(i);
            }else{
                int cur = sk.top(); sk.pop();
                int len = sk.empty() ? i :  i - sk.top() - 1;
                res = max(res, heights[cur]*len);
                i--;
            }
        }
        
        return res;
    }
};

```
