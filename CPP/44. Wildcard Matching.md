# [44. Wildcard Matching](https://leetcode.com/problems/wildcard-matching/description/)
* 这道题的最优解,是双指针的解法,但是其实思想是回溯的思想
* http://blog.csdn.net/woliuyunyicai/article/details/49105557

```c++
    bool isMatch(string s, string p) {
        //i for s, j for p, match记录此时在s中匹配到哪里, start记录在p中上一次*在哪,也就是回溯的时候从什么时候重新开始
        int i=0, j=0, match=0, start=-1; 
        while(i < s.length()){
            // 匹配的情况
            if(j<p.length() && (s[i] == p[j] || p[j]=='?'))
            { 
               i++; 
               j++;
            }
            // 如果出现*,则意味中可以s前面的所有字母都算成匹配上,记录*在p中的位置,记录在s中已经匹配上的位置match,此时注意要j++,而不能i++,因为p中的字母可能下一个等于s[i]
            else if(j<p.length() && p[j] == '*'){
                start = j;
                match = i;
                j++;
            }
            // 没匹配上但是还有*,回溯到之前*的位置再进行匹配,p回溯到*之后的一个位置(因为*被用了), s回溯到match之后的位置(match之前算匹配了)
            else if(start != -1){ // 这里不能加j<p.length()的限制,因为会有"aa""*"这种case,回溯到时候j是可以到达最后的
                j = start+1;
                match++;
                i = match;    
            }else{
                // 没匹配上也没*, 返回false
                return false;
            }
        }
        
        while(j < p.length() && p[j] == '*') j++; //s走完了还要考虑p之后有没有字母,必须都是*才可以返回true
        return j == p.length();
    }
```
