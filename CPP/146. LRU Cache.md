# [146. LRU Cache](https://leetcode.com/problems/lru-cache/?tab=Description)
* 时间是O(n)的解法，用两个map，分别存储数据和对应的访问时间，每次访问，时间+1；
* put时遍历时间的map，找到最小时间（最久未访问），删除

```c++
class LRUCache {
public:
    LRUCache(int capacity) {
        time = 0;
        this->capacity = capacity;
    }
    
    int get(int key) {
        if(!map.count(key))
            return -1;
        time_map[key] = ++time;
        return map[key];
    }
    
    void put(int key, int value) {
        // attention: key should not be in the map, other wise, update it directly
        if(map.size() < capacity && !map.count(key)){
            map[key] = value;
            time_map[key] = ++time;
        }else{
            if(!map.count(key)){
                // find the LRU
                unordered_map<int, int>:: iterator it = time_map.begin();
                int mintime = it->second; 
                int minkey = it->first;
                for(; it != time_map.end(); it++){
                    if(it->second < mintime){
                        mintime = it->second;
                        minkey = it->first;
                    }
                }   
            
                map.erase(minkey);
                time_map.erase(minkey);
            }
            
            map[key] = value;
            time_map[key] = ++time;
        }
    }
    
private:
    unordered_map<int, int> map;
    unordered_map<int, int> time_map;
    int time;
    int capacity;

};
```
