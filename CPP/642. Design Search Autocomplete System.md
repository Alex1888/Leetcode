# [642. Design Search Autocomplete System](https://leetcode.com/problems/design-search-autocomplete-system/)
* 自己开始的想法: 用priority_queue;注意是最小堆,频率小的排在前面,因为堆里只保存频率最大的三个
* 还要注意的是要用一个map来保存数据;因为根据题意,每次input的char组成的新的句子也会算作历史数据的
* 这个算法速度非常慢, beat 11%

```c++
class AutocompleteSystem {
struct compareNum{
    // 最小堆, 小的频率排在前面,如果频率相同, 大的string排在前面
    bool operator() (pair<string, int>& a, pair<string, int>& b){
        if(a.second > b.second){
            return true;
        }else if(a.second < b.second){
            return false;
        }
        
        return a.first < b.first;
    }
};
    
public:
    AutocompleteSystem(vector<string> sentences, vector<int> times) {
        for(int i=0; i<times.size(); i++){
            freq[sentences[i]] += times[i];
         }
        
        sentence = "";
    }
    
    vector<string> input(char c) {
        if(c == '#') {
            freq[sentence]++;
            sentence = "";
            return {};
        }
        
        sentence.push_back(c);
               
        for(auto f : freq) {
            bool match = true;
            // 比较句子是否以sentence开头; 也可以用 f.first.find(sentence) == 0, 单数速度会慢很多
            for(int i=0; i<sentence.size(); i++){
                if(sentence[i] != f.first[i]){
                    match = false;
                    break;
                }
            }
            
            if(match){
                q.push({f.first, f.second});
                if(q.size() > 3){
                    q.pop();
                }
            }          
        }
        
        vector<string> res(q.size());
        for(int i= q.size() - 1; i>=0; i--){
            res[i] = q.top().first;
            q.pop();
        }
        
        return res;
    }
    
private:
    string sentence = "";
    priority_queue<pair<string, int>, vector<pair<string, int>>, compareNum> q;
    unordered_map<string, int> freq;
    vector<string> candidates;
    
};



```


* 用Trie树的解法; 思路和上面的几乎一样
* Trie主要用来提高判断一句话是否由当前的单词开头的速度,还是要用priority_queue来实现找最大的
* 这里的Trie几乎就是模板,不同的是多了一个counts, 来记录当前字母对应的句子->此时的历史

```c++
# [642. Design Search Autocomplete System](https://leetcode.com/problems/design-search-autocomplete-system/)
* 自己开始的想法: 用priority_queue;注意是最小堆,频率小的排在前面,因为堆里只保存频率最大的三个
* 还要注意的是要用一个map来保存数据;因为根据题意,每次input的char组成的新的句子也会算作历史数据的
* 这个算法速度非常慢, beat 11%

```c++
class AutocompleteSystem {
struct compareNum{
    // 最小堆, 小的频率排在前面,如果频率相同, 大的string排在前面
    bool operator() (pair<string, int>& a, pair<string, int>& b){
        if(a.second > b.second){
            return true;
        }else if(a.second < b.second){
            return false;
        }
        
        return a.first < b.first;
    }
};
    
public:
    AutocompleteSystem(vector<string> sentences, vector<int> times) {
        for(int i=0; i<times.size(); i++){
            freq[sentences[i]] += times[i];
         }
        
        sentence = "";
    }
    
    vector<string> input(char c) {
        if(c == '#') {
            freq[sentence]++;
            sentence = "";
            return {};
        }
        
        sentence.push_back(c);
               
        for(auto f : freq) {
            bool match = true;
            // 比较句子是否以sentence开头; 也可以用 f.first.find(sentence) == 0, 单数速度会慢很多
            for(int i=0; i<sentence.size(); i++){
                if(sentence[i] != f.first[i]){
                    match = false;
                    break;
                }
            }
            
            if(match){
                q.push({f.first, f.second});
                if(q.size() > 3){
                    q.pop();
                }
            }          
        }
        
        vector<string> res(q.size());
        for(int i= q.size() - 1; i>=0; i--){
            res[i] = q.top().first;
            q.pop();
        }
        
        return res;
    }
    
private:
    string sentence = "";
    priority_queue<pair<string, int>, vector<pair<string, int>>, compareNum> q;
    unordered_map<string, int> freq;
    vector<string> candidates;
    
};



```


```

