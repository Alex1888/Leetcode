# [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/description/)
* http://www.cnblogs.com/grandyang/p/6815227.html
* 分别统计s1和s2中前n1个字符串中各个字符出现的次数，其中n1为字符串s1的长度，这样如果二者字符出现次数的情况完全相同，说明s1和s2中前n1的字符互为全排列关系，那么符合题意了，直接返回true。如果不是的话，那么我们遍历s2之后的字符，对于遍历到的字符，对应的次数加1，由于窗口的大小限定为了n1，所以每在窗口右侧加一个新字符的同时就要在窗口左侧去掉一个字符，每次都比较一下两个哈希表的情况，如果相等，说明存在

```c++
    bool checkInclusion(string s1, string s2) {
        vector<int>m1(128), m2(128);
        int n1 = s1.size(), n2 = s2.size();
        
        for(int i=0; i<n1; i++){
            m1[s1[i]]++;
            m2[s2[i]]++;
        }
        if(m1 == m2) return true;
        
        for(int i=n1; i<n2; i++){
            m2[s2[i]]++;
            m2[s2[i-n1]]--;
            if(m1 == m2) return true;
        }
        
        return false;
    }

```

* java 套用模板 https://leetcode.com/problems/permutation-in-string/discuss/102590/8-lines-slide-window-solution-in-Java
* 不同于用另个map的解法，关键在于start和end之间始终保持所有字母都在s1中，这个是用map值来控制的，map值小于0说明出现不在s1中了个，需要移动start了

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int[] map = new int[26];
        for(char c : s1.toCharArray()) {
            map[c-'a']++;
        }
        
        int n = s2.length();
        int start = 0, end =0;
        while(end < n) {
            char c = s2.charAt(end);
            end++;
            map[c - 'a']--;
            
            while(map[c - 'a'] < 0){
                map[s2.charAt(start) - 'a']++;
                start++;
            }
            
            if(end - start == s1.length()) 
                return true;
        }
        
        return false;
    }
}
```
