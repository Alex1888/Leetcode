# [978. Longest Turbulent Subarray](https://leetcode.com/problems/longest-turbulent-subarray/)
* 自己的版本， 有点不太好理解, 改了好多才cover了所有corner case

```java
    public int maxTurbulenceSize(int[] A) {
        int n = A.length;
        if(n == 0 || n== 1) return n;
        if(n == 2) return A[0] == A[1] ? 1 : 2;
        int res = 0;
        int left = 0;
        boolean isIncrease = A[1] > A[0];
        int count = A[1] == A[0] ? 1 : 2; // 当前之前的技术
        
        for(int i=2; i<A.length; i++){
            if(A[i] == A[i-1]) {
                res = Math.max(res, count);
                count = 1;
                continue;
            }
            if((A[i] > A[i-1] && !isIncrease) || (A[i] < A[i-1] && isIncrease)){
                count++;
                isIncrease = !isIncrease;
            }else{
                count = 2; // 注意及时此时没有形成波浪，那前面仍然有2个
                isIncrease = A[i] > A[i-1];
            }
            
            res = Math.max(res, count);
        }
        
        return res;
    }

```
